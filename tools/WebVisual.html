<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History Network Graph</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <!-- D3.js for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Custom Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        /* Custom styles for graph elements */
        .node-group {
            cursor: grab;
        }
        .node-group:active {
            cursor: grabbing;
        }
        .node-rect {
             stroke-width: 2px;
        }
        .node-text {
            font-size: 12px;
            font-weight: 500;
            fill: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            pointer-events: none; /* Make text unselectable */
        }
        .link {
            fill: none;
            stroke-opacity: 0.7;
        }
        .link.inter-domain {
            stroke-dasharray: 5, 5;
        }
        .arrow {
            fill-opacity: 0.9;
        }
    </style>
    <script>
        // Dark mode initialization
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 antialiased">
    <div class="flex flex-col h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-md p-4 z-10 flex-shrink-0">
            <div class="container mx-auto flex justify-between items-center">
                <h1 class="text-xl md:text-2xl font-bold text-gray-900 dark:text-white">Browsing History Graph</h1>
                <button id="theme-toggle" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none">
                    <!-- Sun icon -->
                    <svg id="theme-toggle-light-icon" class="hidden w-5 h-5 text-gray-500 dark:text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
                    <!-- Moon icon -->
                    <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5 text-gray-500 dark:text-gray-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex-grow flex flex-col md:flex-row overflow-hidden">
            <!-- Controls Panel -->
            <div class="w-full md:w-80 lg:w-96 p-4 bg-white dark:bg-gray-800 border-t md:border-t-0 md:border-r border-gray-200 dark:border-gray-700 overflow-y-auto flex-shrink-0">
                <h2 class="text-lg font-semibold mb-3">Controls</h2>
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Paste a chronological list of URLs below, one per line. The graph will visualize your browsing path.
                </p>
                <textarea id="url-input" class="w-full h-48 md:h-64 p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="https://www.google.com/search?q=d3js\nhttps://d3js.org/\nhttps://d3js.org/getting-started\nhttps://github.com/d3/d3\nhttps://www.google.com/search?q=tailwind+css\nhttps://tailwindcss.com/\n..."></textarea>
                <button id="render-button" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">
                    Render Graph
                </button>
                 <div id="instructions" class="mt-6 text-sm text-gray-500 dark:text-gray-400 space-y-2">
                    <p><b>Zoom:</b> Use your mouse wheel or pinch on a touchscreen.</p>
                    <p><b>Pan/Scroll:</b> Click and drag, or swipe on a touchscreen.</p>
                 </div>
            </div>

            <!-- Graph Area -->
            <main class="flex-grow bg-gray-200 dark:bg-gray-900 relative min-h-[300px] md:min-h-0" id="graph-container">
                 <!-- Loading Indicator (Throbber) -->
                <div id="loader" class="absolute inset-0 bg-gray-200 dark:bg-gray-900 bg-opacity-75 dark:bg-opacity-75 flex items-center justify-center z-20 hidden">
                    <svg class="animate-spin h-10 w-10 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </main>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const renderButton = document.getElementById('render-button');
            const urlInput = document.getElementById('url-input');
            const graphContainer = document.getElementById('graph-container');
            const loader = document.getElementById('loader');

            urlInput.value = [
                'https://www.google.com/search?q=data+visualization',
                'https://en.wikipedia.org/wiki/Data_visualization',
                'https://en.wikipedia.org/wiki/Infographic',
                'https://en.wikipedia.org/wiki/Edward_Tufte',
                'https://www.google.com/search?q=d3.js+force+layout',
                'https://observablehq.com/@d3/force-directed-graph',
                'https://github.com/d3/d3-force',
                'https://www.youtube.com/watch?v=pGJ_tq_Oh3c',
                'https://www.youtube.com/watch?v=nTSru6L20lc',
                'https://www.reddit.com/r/dataisbeautiful/',
                'https://www.google.com/search?q=web+design+inspiration',
                'https://www.awwwards.com/',
                'https://www.awwwards.com/websites/clean/',
                'https://dribbble.com/',
                'https://dribbble.com/shots/popular/web-design'
            ].join('\n');
            
            let simulation;

            const renderGraph = () => {
                if (simulation) simulation.stop();

                loader.classList.remove('hidden');
                d3.select(graphContainer).select('svg').remove();
                const existingError = graphContainer.querySelector('.error-message');
                if (existingError) existingError.remove();

                setTimeout(() => {
                    const rawText = urlInput.value.trim();
                    if (!rawText) {
                        graphContainer.innerHTML += `<div class="flex items-center justify-center h-full text-gray-500">Please paste some URLs to begin.</div>`;
                        loader.classList.add('hidden');
                        return;
                    }
                    
                    const width = graphContainer.clientWidth;
                    const height = graphContainer.clientHeight;

                    if (width <= 0 || height <= 0) {
                        graphContainer.innerHTML += `<div class="error-message flex items-center justify-center h-full text-red-500">Error: Graph container has no size.</div>`;
                        loader.classList.add('hidden');
                        return;
                    }

                    const urls = rawText.split('\n').filter(Boolean);

                    const nodes = urls.map((url, i) => {
                        let domain = 'unknown';
                        try {
                            domain = new URL(url).hostname.replace('www.', '');
                        } catch (e) {
                            domain = url.split('/')[0] || 'invalid-url';
                        }
                        return { id: i, url: url, domain: domain, timestamp: i };
                    });

                    const links = [];
                    for (let i = 0; i < nodes.length - 1; i++) {
                        links.push({
                            source: nodes[i],
                            target: nodes[i + 1],
                            type: nodes[i].domain === nodes[i+1].domain ? 'intra-domain' : 'inter-domain'
                        });
                    }

                    const xScale = d3.scaleLinear().domain([0, nodes.length - 1]).range([150, width - 150]);
                    const uniqueDomains = [...new Set(nodes.map(d => d.domain))];
                    const yScale = d3.scalePoint().domain(uniqueDomains).range([100, height - 100]).padding(0.5);
                    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(uniqueDomains);

                    nodes.forEach(node => {
                        node.x = xScale(node.timestamp);
                        node.y = yScale(node.domain);
                    });
                    
                    const svg = d3.select(graphContainer).append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    const g = svg.append('g');
                    
                    const node = g.append('g')
                        .selectAll('.node-group')
                        .data(nodes)
                        .join('g')
                        .attr('class', 'node-group');

                    const nodeText = node.append('text')
                        .attr('class', 'node-text')
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'central')
                        .text(d => d.domain);
                    
                    const padding = { x: 10, y: 5 };
                    node.each(function(d) {
                        const bbox = d3.select(this).select('text').node().getBBox();
                        d.width = bbox.width + 2 * padding.x;
                        d.height = bbox.height + 2 * padding.y;
                    });

                    node.insert('rect', 'text')
                        .attr('class', 'node-rect')
                        .attr('width', d => d.width)
                        .attr('height', d => d.height)
                        .attr('x', d => -d.width / 2)
                        .attr('y', d => -d.height / 2)
                        .attr('rx', 8)
                        .attr('fill', d => colorScale(d.domain))
                        .attr('stroke', d => d3.color(colorScale(d.domain)).darker(1));

                    simulation = d3.forceSimulation(nodes)
                        // *** FIX: Added X-force to maintain chronological order ***
                        .force('x', d3.forceX(d => xScale(d.timestamp)).strength(0.2))
                        .force('y', d3.forceY(d => yScale(d.domain)).strength(0.1))
                        .force('collide', d3.forceCollide().radius(d => d.width / 2 + 5).strength(1))
                        .on('tick', ticked);

                    g.append('defs').selectAll('marker')
                        .data(links.filter(l => l.type === 'inter-domain'))
                        .join('marker')
                        .attr('id', d => `arrow-${d.target.id}`)
                        .attr('viewBox', '0 -5 10 10').attr('refX', 5).attr('refY', 0)
                        .attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto')
                        .append('path').attr('d', 'M0,-5L10,0L0,5')
                        .attr('fill', d => colorScale(d.source.domain)).attr('class', 'arrow');

                    const link = g.append('g').selectAll('path').data(links).join('path')
                        .attr('class', d => `link ${d.type}`)
                        .attr('stroke', d => colorScale(d.source.domain))
                        .attr('stroke-width', 2)
                        .attr('marker-end', d => d.type === 'inter-domain' ? `url(#arrow-${d.target.id})` : null);
                    
                    node.call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));

                    const zoom = d3.zoom().scaleExtent([0.1, 8]).on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                    svg.call(zoom);

                    function ticked() {
                        link.attr('d', d => arcPath(d));
                        node.attr('transform', d => `translate(${d.x},${d.y})`);
                    }

                    // *** FIX: Rectangle Intersection Algorithm ***
                    function getIntersection(source, target) {
                        const w = target.width / 2;
                        const h = target.height / 2;
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        
                        if (dx === 0 && dy === 0) return { x: target.x, y: target.y };

                        const tanPhi = h / w;
                        const tanTheta = Math.abs(dy / dx);
                        
                        let ix, iy;

                        if (tanTheta < tanPhi) {
                            // Intersects left or right side
                            const signX = dx > 0 ? -1 : 1;
                            ix = target.x + signX * w;
                            iy = target.y + signX * w * (dy / dx);
                        } else {
                            // Intersects top or bottom side
                            const signY = dy > 0 ? -1 : 1;
                            ix = target.x + signY * h * (dx / dy);
                            iy = target.y + signY * h;
                        }
                        return { x: ix, y: iy };
                    }

                    function arcPath(d) {
                        const source = d.source; 
                        const target = d.target;
                        
                        // Calculate intersection points for both source and target to have clean lines
                        // For source, we want the point where the line LEAVES the box
                        // For target, we want the point where the line ENTERS the box
                        
                        // We can use the same logic, just reversing the direction for source
                        const targetInt = getIntersection(source, target);
                        const sourceInt = getIntersection(target, source);

                        const dx = targetInt.x - sourceInt.x;
                        const dy = targetInt.y - sourceInt.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist === 0) return '';

                        const dr = dist * 1.5; // Curve radius
                        const sweep = (d.source.id % 2 === 0) ? 1 : 0;

                        return `M${sourceInt.x},${sourceInt.y}A${dr},${dr} 0 0,${sweep} ${targetInt.x},${targetInt.y}`;
                    }
                    
                    // *** FIX: Correct drag handlers using d3.pointer ***
                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        const [px, py] = d3.pointer(event, g.node());
                        d.fx = px;
                        d.fy = py;
                    }
                    function dragged(event, d) {
                        const [px, py] = d3.pointer(event, g.node());
                        d.fx = px;
                        d.fy = py;
                    }
                    function dragended(event, d) {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    }
                    
                    loader.classList.add('hidden');

                }, 20);
            };

            renderButton.addEventListener('click', renderGraph);

            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (d3.select(graphContainer).select('svg').node()) {
                       renderGraph();
                    }
                }, 250); // Debounce resize event
            });

            renderGraph();

            // Dark Mode Toggle Logic
            const themeToggleBtn = document.getElementById('theme-toggle');
            const darkIcon = document.getElementById('theme-toggle-dark-icon');
            const lightIcon = document.getElementById('theme-toggle-light-icon');

            // Change the icons inside the button based on previous settings
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                lightIcon.classList.remove('hidden');
            } else {
                darkIcon.classList.remove('hidden');
            }

            themeToggleBtn.addEventListener('click', function() {
                // toggle icons inside button
                darkIcon.classList.toggle('hidden');
                lightIcon.classList.toggle('hidden');

                // if set via local storage previously
                if (localStorage.getItem('theme')) {
                    if (localStorage.getItem('theme') === 'light') {
                        document.documentElement.classList.add('dark');
                        localStorage.setItem('theme', 'dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                        localStorage.setItem('theme', 'light');
                    }
                } else {
                    // if NOT set via local storage previously
                    if (document.documentElement.classList.contains('dark')) {
                        document.documentElement.classList.remove('dark');
                        localStorage.setItem('theme', 'light');
                    } else {
                        document.documentElement.classList.add('dark');
                        localStorage.setItem('theme', 'dark');
                    }
                }
            });
        });
    </script>
</body>
</html>